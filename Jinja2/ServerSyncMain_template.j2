#include <iostream>
#include <fstream>
#include <thread>
#include <chrono>
#include <cstring>
#include <cstdlib>
#include <cerrno>
#include <netdb.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <nlohmann/json.hpp>
{% for service_name in data %}
#include "../rpc_server_inc/{{ service_name }}_impl.h"
{% endfor %}
using json = nlohmann::json;

{% for service_name in data %}
class {{ service_name }}_Service_ServerImpl ;
{% endfor%}

void loadConfig(const std::string& filename, std::string& ip, std::string& port,
        std::string& broadcastAddress, std::string& broadcastPort) {
    std::ifstream config_file(filename);
    if (!config_file.is_open()) {
        std::cerr << "Failed to open configuration file: " << filename << std::endl;
        return;
    }
    try {
        json config = json::parse(config_file);
        ip = config["server"]["ip"].get<std::string>();
        port = config["server"]["port"].get<std::string>();
        broadcastAddress = config["server"]["broadcastAddress"].get<std::string>();
        broadcastPort = config["server"]["broadcastPort"].get<std::string>();
    } catch (const json::parse_error& e) {
        std::cerr << "JSON parse error: " << e.what() << std::endl;
    } catch (const json::type_error& e) {
        std::cerr << "JSON type error: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "An unexpected error occurred while parsing the JSON file." << std::endl;
    }
}

void createSystemStatusJson(json& js) {
    js["system_version"] = "1.0";
    js["architecture"] = "x86_64";
    // other system_Status_info...
    js["memory_usage"] = "10086";
    js["network_usage"] = "11111";
    js["answer"]["everything"] = "Ubuntu20.04";
    js["object"] = { {"currency", "USD"}, {"value", 42.99} };
}

void udpSender(const char* server_host, const char* server_port) {
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        std::cerr << "Cannot open socket: " << strerror(errno) << std::endl;
        return;
    }
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(atoi(server_port));

    if (inet_pton(AF_INET, server_host, &serv_addr.sin_addr) <= 0) {
        std::cerr << "Invalid address / Address not supported: " << strerror(errno) << std::endl;
        close(sockfd);
        return;
    }
    json j;
    createSystemStatusJson(j);
    while (true) {
        sendto(sockfd, j.dump().c_str(), j.dump().length(), 0,
               (const struct sockaddr *) &serv_addr, sizeof(serv_addr));
        std::this_thread::sleep_for(std::chrono::seconds(1)); // sleep for 1 second
    }
    close(sockfd);
}

void udpReceiver(uint16_t listen_port) {
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        std::cerr << "Cannot open socket: " << strerror(errno) << std::endl;
        return;
    }
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(listen_port);
    if (bind(sockfd, (const struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        std::cerr << "Cannot bind socket: " << strerror(errno) << std::endl;
        close(sockfd);
        return;
    }
    char buffer[1024];
    socklen_t len = sizeof(serv_addr);
    while (true) {
        ssize_t byte_read = recvfrom(sockfd, buffer, sizeof(buffer), 0,
                                     (struct sockaddr *) &serv_addr, &len);
        if (byte_read > 0) {
            // handle received data
            std::cout << "Received data: " << std::string(buffer, byte_read) << std::endl;
        }
    }
    close(sockfd);
}

nlohmann::json readJsonDataFromFile(const std::string& file_path) {
    std::ifstream json_file(file_path);
    if (!json_file.is_open()) {
        throw std::runtime_error("Cannot open JSON file");
    }
    nlohmann::json j;
    json_file >> j;
    return j;
}

nlohmann::json readJsonFile(const std::string& filename) {
    std::ifstream jsonFile(filename);
    if (!jsonFile.is_open()) {
        throw std::runtime_error("Cannot open file: " + filename);
    }

    try {
        nlohmann::json j;
        jsonFile >> j;
        return j;
    } catch (const json::parse_error& pe) {
        std::cerr << "JSON parse error: " << pe.what() << std::endl;
        throw; 
    }
}

void broadcastStructData(const std::string& broadcastIP, const std::string& broadcastPort) {
    
    const char *broadcastMessage = R"({"message": "Hello, broadcast!", "time": "2024-08-18T17:10:00Z"})";
    //const char *broadcastIP = "255.255.255.255";
    //int broadcastPort = 12345;

    // Create a UDP socket
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock == -1) {
        std::cerr << "Error creating socket" << std::endl;
        return ;
    }
    // Set the broadcast option
    int broadcastPermission = 1;
    if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &broadcastPermission, sizeof(broadcastPermission)) == -1) {
        std::cerr << "Error setting broadcast option" << std::endl;
        close(sock);
        return ;
    }
    // Prepare the address structure
    struct sockaddr_in broadcastAddr;
    memset(&broadcastAddr, 0, sizeof(broadcastAddr));
    broadcastAddr.sin_family = AF_INET;
    broadcastAddr.sin_port = htons(atoi(broadcastPort.c_str()));
    if (inet_aton(broadcastIP.c_str(), &broadcastAddr.sin_addr) == 0) {
        std::cerr << "Invalid broadcast IP address" << std::endl;
        close(sock);
        return ;
    }
    // Send the broadcast message
    while(true){
        if (sendto(sock, broadcastMessage, strlen(broadcastMessage), 0,
               (struct sockaddr *) &broadcastAddr, sizeof(broadcastAddr)) == -1) {
        std::cerr << "Error sending broadcast message" << std::endl;
        close(sock);
        return ;
    }
    std::cout << "Broadcast message sent successfully." << std::endl;
    }
    close(sock);
}

void broadcastJsonData(const std::string& broadcastAddress, const std::string& port, const nlohmann::json& j) {
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        std::cerr << "Cannot open socket" << std::endl;
        return;
    }
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(atoi(port.c_str()));
    inet_pton(AF_INET, broadcastAddress.c_str(), &serv_addr.sin_addr);

    int opt = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &opt, sizeof(opt))) {
        perror("setsockopt");
        close(sockfd);
        return;
    }

    const std::string message = j.dump();
    while (true) {
        if (sendto(sockfd, message.c_str(), message.size(), 0,
                  (const struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            perror("sendto");
        }
        //std::cout << "Broadcast JSON data: " << message << std::endl;
        std::cout << "Broadcast JSON data Successfully...... "<< std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1)); // sleep for 1 second
    }
}

void RunServer(const std::string& ip, const std::string& port) {
    std::string server_address(ip+":"+port);
    ::grpc::ServerBuilder builder;
    builder.AddListeningPort(server_address, ::grpc::InsecureServerCredentials());
    // TODO add service
    {% for service_name in data %}
    {{ service_name }}_Service_ServerImpl {{ service_name }}_instance;
    builder.RegisterService(&{{ service_name }}_instance);
    {% endfor %}
    std::unique_ptr<::grpc::Server> server(builder.BuildAndStart());
    std::cout << ">>>> Server listening on " << server_address << std::endl;
    server->Wait();
}

int main(int argc, char** argv) {

    std::string ip;
    std::string port;
    std::string broadcastAddress;  // Default broadcast addressIP "192.168.0.255"
    std::string broadcastPort;     // Default broadcast port
    // Load configurationInfo from ../Jinja2/ServerBaseInfo.json

    loadConfig("../Jinja2/ServerBaseInfo.json", ip, port, broadcastAddress, broadcastPort);

    std::cout << ">>>>[INFO] Server IP: " << ip << std::endl;
    std::cout << ">>>>[INFO] Server Port: " << port << std::endl;
    std::cout << ">>>>[INFO] Broadcast Address: " << broadcastAddress << std::endl;
    std::cout << ">>>>[INFO] Broadcast Port: " << broadcastPort << std::endl;
    
    json js;
    createSystemStatusJson(js);

    //auto j = readJsonDataFromFile("../Jinja2/ServerBaseInfo.json");
    //nlohmann::json j = readJsonFile("../Jinja2/ServerBaseInfo.json");
    nlohmann::json j = readJsonFile("../Jinja2/ServerInfo.json");

    //createSystemStatusJson(j);
    //std::thread senderThread(broadcastJsonData, broadcastAddress, broadcastPort, std::cref(j));
    std::thread senderThread(broadcastJsonData, broadcastAddress, broadcastPort, j);
    // TODO: Add other threads here
    
    RunServer(ip,port);
    
    senderThread.join();
    // TODO: Add other threads here
    //runServerThread.join();
    return 0;
}