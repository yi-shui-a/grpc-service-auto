#include <iostream>
#include <memory>
#include <string>
#include <thread>
#include <grpcpp/grpcpp.h>
#include "../protos/{{ package.atom_name|lower }}.grpc.pb.h"
#include "../atom_inc/{{ package.atom_name|lower }}.h"
{# #include "{{ services.name }}_server_impl.h" #}
class {{ package.service_name }}_ServerImpl final : public ::{{package.package_name}}::{{ package.service_name }}::Service {
public:
    {{ package.service_name }}_ServerImpl() {}
    {% for method in services.methods %}
    {% if method.name == "UnitaryStream" %}
    ::grpc::Status {{ method.name }}(grpc::ServerContext* context, 
            const ::{{package.package_name}}::{{ package.request_name }}* request, 
                  ::{{package.package_name}}::{{ package.reply_name }}* reply) override {
        ::{{package.package_name}}::{{ package.request_name }} request;
        ::{{package.package_name}}::{{ package.reply_name }} reply;
        // {{ package.request_name }} Mapping to --> struct {{ package.request_name }}_t
        typedef struct {{ package.request_name }}_stuct {
            {% for dataType in messages.request.fields %}
            {% if dataType.repeated == true %}
                {% if dataType.type == "int32"%}
                std::vector<{{ (dataType.type) }}_t> {{ dataType.name }}_ ;
                {% else %}
                std::vector<{{ (dataType.type) }}> {{ dataType.name }}_ ;
                {% endif %}
            {% elif dataType.map == true %}
                std::{{dataType.type}} {{ dataType.name }}_ ;
            {% elif dataType.type == "string" %}
                std::string {{ dataType.name }}_ ;
            {% elif dataType.type == "int32" %}
                int {{ dataType.name }}_ ;
            {% elif dataType.type == "bool" %}
                bool {{ dataType.name }}_ ;
            {% else %}
                {{ dataType.type }} {{ dataType.name }}_ ;
            {% endif %}
        {% endfor %}
        } {{ package.request_name }}_st;

        typedef struct {{ package.reply_name }}_stuct {
            {% for dataType in messages.request.fields %}
            {% if dataType.repeated == true %}
                {% if dataType.type == "int32"%}
                std::vector<{{ (dataType.type) }}_t> {{ dataType.name }}_ ;
                {% else %}
                std::vector<{{ (dataType.type) }}> {{ dataType.name }}_ ;
                {% endif %}
            {% elif dataType.map == true %}
                std::{{dataType.type}} {{ dataType.name }}_ ;
            {% elif dataType.type == "string" %}
                std::string {{ dataType.name }}_ ;
            {% elif dataType.type == "int32" %}
                int {{ dataType.name }}_ ;
            {% elif dataType.type == "bool" %}
                bool {{ dataType.name }}_ ;
            {% else %}
                {{ dataType.type }} {{ dataType.name }}_ ;
            {% endif %}
        {% endfor %}
        } {{ package.reply_name }}_st;

        //int ret = atom_server_sj(request->integer_field(), request->integer_field());
        //reply->set_integer_reply(ret);
        //std::cout << "ret: " << ret << std::endl;
        //std::string prefix("Hello ");
        //reply->set_message(prefix + request->name());
        //reply->set_double_reply(request->double_field());
        //reply->set_float_reply(request->float_field());
        //*reply->mutable_int_array_reply() = request->int_array();
        //*reply->mutable_string_int_map_reply() = request->string_int_map();
        // Extract the google::protobuf::Map and populate an std::map
        //std::map<std::string, int32_t> extracted_map;
        //for (auto it = request->string_int_map().begin(); it != request->string_int_map().end(); ++it) {
        //    extracted_map[it->first] = it->second;
        //}   
        
        // call atom interface
        // int ret = {{ package.atom_interface }}(vector_vec[0], vector_vec[1]);

        {{ package.reply_name }}_st  {{ package.reply_name }}_t;
        void  {{ package.atom_interface }}(
            {% for dataType in messages.request.fields %}
            {% if dataType.repeated == true %}
                {% if dataType.type == "int32"%}
                {{ dataType.name }} = request->{{ dataType.name }}(),
                {% else %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
                {% endif %}
            {% elif dataType.map == true %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% elif dataType.type == "string" %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% elif dataType.type == "int32" %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% elif dataType.type == "bool" %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% else %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% endif %}
            
        {% endfor %}
                &{{ package.reply_name }}_t
        )

        if (ret == 0) {
            return grpc::Status(grpc::StatusCode::UNKNOWN, "error");
        }
        std::cout << "This is Method={{ method.name }} ServiceName={{package.service_name}}" << std::endl;
        return grpc::Status::OK;
    }
    // ServerStream method
    {% elif method.name == "ServerStream" %}
    ::grpc::Status {{ method.name }}(grpc::ServerContext* context, 
                const ::{{package.package_name}}::{{ package.request_name }}* request, 
                ::grpc::ServerWriter<::{{package.package_name}}::{{ package.reply_name }}>* writer) override {
        for (int i=0; i < 5; ++i){
            
        }
        std::cout << "This is ServerStream" << std::endl;
        std::cout << "This is Method={{ method.name }} ServiceName={{package.service_name}}" << std::endl;
        return grpc::Status::OK;
    }
    // ClientStream rpc method
    {% elif method.name == "ClientStream"  %}
    ::grpc::Status {{ method.name }}(grpc::ServerContext* context, 
            ::grpc::ServerReader< ::{{package.package_name}}::{{ package.request_name }}>* reader, 
            ::{{package.package_name}}::{{ package.reply_name }}* reply) override {
        std::cout << "This is ClientStream" << std::endl;
        std::cout << "This is Method={{ method.name }} ServiceName={{package.service_name}}" << std::endl;
        return grpc::Status::OK;
    }
    // BidirectionalStream rpc method
    {% elif method.name == "BidirectionalStream"  %}
    ::grpc::Status {{ method.name }}(grpc::ServerContext* context, 
            ::grpc::ServerReaderWriter< ::{{package.package_name}}::{{ package.reply_name }} , 
            ::{{package.package_name}}::{{ package.request_name }}>* stream) override {
        std::cout << "This is BidirectionalStream" << std::endl;
        std::cout << "This is Method={{ method.name }} ServiceName={{package.service_name}}" << std::endl;
        return grpc::Status::OK;
    }
    {% else %}
    {% endif %}
    {% endfor %}
};
#include <iostream>
#include <memory>
#include <string>
#include <thread>
#include <grpcpp/grpcpp.h>
#include "../protos/{{ package.atom_name|lower }}.grpc.pb.h"
#include "../atom_inc/{{ package.atom_name|lower }}.h"
{# #include "{{ services.name }}_server_impl.h" #}
class {{ package.service_name }}_ServerImpl final : public ::{{package.package_name}}::{{ package.service_name }}::Service {
public:
    {{ package.service_name }}_ServerImpl() {} 
    {% for method in services.methods %}
    {% if method.name == "UnitaryStream" %}
    ::grpc::Status {{ method.name }}(grpc::ServerContext* context, 
            const ::{{package.package_name}}::{{ package.request_name }}* request, 
                  ::{{package.package_name}}::{{ package.reply_name }}* reply) override {
        ::{{package.package_name}}::{{ package.request_name }} request;
        ::{{package.package_name}}::{{ package.reply_name }} reply;
        // {{ package.request_name }} Mapping to --> struct {{ package.request_name }}_t
        typedef struct {{ package.request_name }}_stuct {
            {% for dataType in messages.request.fields %}
            {% if dataType.repeated == true %}
                {% if dataType.type == "int32"%}
                std::vector<{{ (dataType.type) }}_t> {{ dataType.name }}_ ;
                {% else %}
                std::vector<{{ (dataType.type) }}> {{ dataType.name }}_ ;
                {% endif %}
            {% elif dataType.map == true %}
                std::{{dataType.type}} {{ dataType.name }}_ ;
            {% elif dataType.type == "string" %}
                std::string {{ dataType.name }}_ ;
            {% elif dataType.type == "int32" %}
                int {{ dataType.name }}_ ;
            {% elif dataType.type == "bool" %}
                bool {{ dataType.name }}_ ;
            {% else %}
                {{ dataType.type }} {{ dataType.name }}_ ;
            {% endif %}
        {% endfor %}
        } {{ package.request_name }}_st;

        typedef struct {{ package.reply_name }}_stuct {
            {% for dataType in messages.request.fields %}
            {% if dataType.repeated == true %}
                {% if dataType.type == "int32"%}
                std::vector<{{ (dataType.type) }}_t> {{ dataType.name }}_ ;
                {% else %}
                std::vector<{{ (dataType.type) }}> {{ dataType.name }}_ ;
                {% endif %}
            {% elif dataType.map == true %}
                std::{{dataType.type}} {{ dataType.name }}_ ;
            {% elif dataType.type == "string" %}
                std::string {{ dataType.name }}_ ;
            {% elif dataType.type == "int32" %}
                int {{ dataType.name }}_ ;
            {% elif dataType.type == "bool" %}
                bool {{ dataType.name }}_ ;
            {% else %}
                {{ dataType.type }} {{ dataType.name }}_ ;
            {% endif %}
        {% endfor %}
        } {{ package.reply_name }}_st;

     

        //int ret = atom_server_sj(request->integer_field(), request->integer_field());
        //reply->set_integer_reply(ret);
        //std::cout << "ret: " << ret << std::endl;
        //std::string prefix("Hello ");
        //reply->set_message(prefix + request->name());
        //reply->set_double_reply(request->double_field());
        //reply->set_float_reply(request->float_field());
        //*reply->mutable_int_array_reply() = request->int_array();
        //*reply->mutable_string_int_map_reply() = request->string_int_map();
        // Extract the google::protobuf::Map and populate an std::map
        //std::map<std::string, int32_t> extracted_map;
        //for (auto it = request->string_int_map().begin(); it != request->string_int_map().end(); ++it) {
        //    extracted_map[it->first] = it->second;
        //}   
        
        // call atom interface
        // int ret = {{ package.atom_interface }}(vector_vec[0], vector_vec[1]);

        {{ package.reply_name }}_st  {{ package.reply_name }}_t;
        void  {{ package.atom_interface }}(
            {% for dataType in messages.request.fields %}
            {% if dataType.repeated == true %}
                {% if dataType.type == "int32"%}
                {{ dataType.name }} = request->{{ dataType.name }}(),
                {% else %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
                {% endif %}
            {% elif dataType.map == true %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% elif dataType.type == "string" %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% elif dataType.type == "int32" %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% elif dataType.type == "bool" %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% else %}
                {{ dataType.name }} = request->{{ dataType.name }}(),
            {% endif %}
            
        {% endfor %}
                &{{ package.reply_name }}_t
        )




        if (ret == 0) {
            return grpc::Status(grpc::StatusCode::UNKNOWN, "error");
        }
        std::cout << "This is Method={{ method.name }} ServiceName={{package.service_name}}" << std::endl;
        return grpc::Status::OK;
    }
    // ServerStream method
    {% elif method.name == "ServerStream" %}
    ::grpc::Status {{ method.name }}(grpc::ServerContext* context, 
                const ::{{package.package_name}}::{{ package.request_name }}* request, 
                ::grpc::ServerWriter<::{{package.package_name}}::{{ package.reply_name }}>* writer) override {
        for (int i=0; i < 5; ++i){
            
        }
        std::cout << "This is ServerStream" << std::endl;
        std::cout << "This is Method={{ method.name }} ServiceName={{package.service_name}}" << std::endl;
        return grpc::Status::OK;
    }
    // ClientStream rpc method
    {% elif method.name == "ClientStream"  %}
    ::grpc::Status {{ method.name }}(grpc::ServerContext* context, 
            ::grpc::ServerReader< ::{{package.package_name}}::{{ package.request_name }}>* reader, 
            ::{{package.package_name}}::{{ package.reply_name }}* reply) override {
        std::cout << "This is ClientStream" << std::endl;
        std::cout << "This is Method={{ method.name }} ServiceName={{package.service_name}}" << std::endl;
        return grpc::Status::OK;
    }
    // BidirectionalStream rpc method
    {% elif method.name == "BidirectionalStream"  %}
    ::grpc::Status {{ method.name }}(grpc::ServerContext* context, 
            ::grpc::ServerReaderWriter< ::{{package.package_name}}::{{ package.reply_name }} , 
            ::{{package.package_name}}::{{ package.request_name }}>* stream) override {
        std::cout << "This is BidirectionalStream" << std::endl;
        std::cout << "This is Method={{ method.name }} ServiceName={{package.service_name}}" << std::endl;
        return grpc::Status::OK;
    }
    {% else %}
    {% endif %}
    {% endfor %}
};